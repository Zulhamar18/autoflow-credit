"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransactions = exports.ankrTransactionTransformer = void 0;
const url_js_1 = require("../../utils/url.js");
const ankrTransactionTransformer = (txn) => ({
    blockhash: txn?.blockHash,
    blocktime: txn.blockTime,
    confirmations: txn.confirmations,
    hex: txn.hex,
    locktime: txn?.coinSpecificData?.locktime,
    hash: txn.coinSpecificData?.hash,
    size: txn.size,
    txid: txn.txid,
    version: txn.version,
    vin: txn.vin.map((vin) => ({
        scriptSig: vin.scriptSig,
        sequence: vin.sequence,
        txid: vin.txid,
        vout: vin.vout,
        txinwitness: vin.addresses,
    })),
    vsize: txn.vsize,
    vout: txn.vout.map((vout) => ({
        n: vout.n,
        scriptPubKey: vout.scriptPubKey,
        value: vout.value,
    })),
});
exports.ankrTransactionTransformer = ankrTransactionTransformer;
const getTransactions = async (client, { baseUrl }, { address, limit = 50, offset = 0, lastBlock }) => {
    const apiUrl = (0, url_js_1.urlWithParams)(`${baseUrl}/address/${address}`, {
        details: 'txs',
        pageSize: limit,
        to: lastBlock,
    });
    const response = (await client.request({
        url: apiUrl,
        fetchOptions: { method: 'GET' },
    }));
    if (response.error) {
        return { error: response.error };
    }
    const total = response.txs || 0;
    const page = Math.floor(offset / limit) + 1;
    const hasMore = total > offset + response.transactions.length;
    const data = {
        transactions: response.transactions.map(exports.ankrTransactionTransformer),
        total,
        page,
        itemsPerPage: limit,
        hasMore,
    };
    return { result: data };
};
exports.getTransactions = getTransactions;
//# sourceMappingURL=getTransactions.js.map