"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNativePermit = void 0;
const viem_1 = require("viem");
const actions_1 = require("viem/actions");
const abi_js_1 = require("../abi.js");
const getActionWithFallback_js_1 = require("../getActionWithFallback.js");
const utils_js_1 = require("../utils.js");
const EIP712_DOMAIN_TYPEHASH = '0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f';
const EIP712_DOMAIN_TYPEHASH_WITH_SALT = '0x36c25de3e541d5d970f66e4210d728721220fff5c077cc6cd008b3a0c62adab7';
function makeDomainSeparator({ name, version, chainId, verifyingContract, withSalt = false, }) {
    const nameHash = (0, viem_1.keccak256)((0, viem_1.toBytes)(name));
    const versionHash = (0, viem_1.keccak256)((0, viem_1.toBytes)(version));
    const encoded = withSalt
        ? (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)('bytes32, bytes32, bytes32, address, bytes32'), [
            EIP712_DOMAIN_TYPEHASH_WITH_SALT,
            nameHash,
            versionHash,
            verifyingContract,
            (0, viem_1.pad)((0, viem_1.toHex)(chainId), { size: 32 }),
        ])
        : (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)('bytes32, bytes32, bytes32, uint256, address'), [
            EIP712_DOMAIN_TYPEHASH,
            nameHash,
            versionHash,
            BigInt(chainId),
            verifyingContract,
        ]);
    return (0, viem_1.keccak256)(encoded);
}
function validateDomainSeparator({ name, version, chainId, verifyingContract, domainSeparator, }) {
    if (!name || !domainSeparator) {
        return {
            isValid: false,
            domain: {},
        };
    }
    for (const withSalt of [false, true]) {
        const computedDS = makeDomainSeparator({
            name,
            version,
            chainId,
            verifyingContract,
            withSalt,
        });
        if (domainSeparator.toLowerCase() === computedDS.toLowerCase()) {
            return {
                isValid: true,
                domain: withSalt
                    ? {
                        name,
                        version,
                        verifyingContract,
                        salt: (0, viem_1.pad)((0, viem_1.toHex)(chainId), { size: 32 }),
                    }
                    : {
                        name,
                        version,
                        chainId,
                        verifyingContract,
                    },
            };
        }
    }
    return {
        isValid: false,
        domain: {},
    };
}
const getNativePermit = async (client, { chainId, tokenAddress, spenderAddress, amount }) => {
    try {
        const multicallAddress = await (0, utils_js_1.getMulticallAddress)(chainId);
        const contractCalls = [
            {
                address: tokenAddress,
                abi: abi_js_1.eip2612Abi,
                functionName: 'name',
            },
            {
                address: tokenAddress,
                abi: abi_js_1.eip2612Abi,
                functionName: 'DOMAIN_SEPARATOR',
            },
            {
                address: tokenAddress,
                abi: abi_js_1.eip2612Abi,
                functionName: 'nonces',
                args: [client.account.address],
            },
            {
                address: tokenAddress,
                abi: abi_js_1.eip2612Abi,
                functionName: 'version',
            },
        ];
        if (multicallAddress) {
            try {
                const [nameResult, domainSeparatorResult, noncesResult, versionResult] = await (0, getActionWithFallback_js_1.getActionWithFallback)(client, actions_1.multicall, 'multicall', {
                    contracts: contractCalls,
                    multicallAddress,
                });
                if (nameResult.status !== 'success' ||
                    domainSeparatorResult.status !== 'success' ||
                    noncesResult.status !== 'success' ||
                    !nameResult.result ||
                    !domainSeparatorResult.result ||
                    noncesResult.result === undefined) {
                    throw new Error('Multicall failed');
                }
                const { isValid, domain } = validateDomainSeparator({
                    name: nameResult.result,
                    version: versionResult.result ?? '1',
                    chainId,
                    verifyingContract: tokenAddress,
                    domainSeparator: domainSeparatorResult.result,
                });
                if (!isValid) {
                    return undefined;
                }
                const message = {
                    owner: client.account.address,
                    spender: spenderAddress,
                    value: amount.toString(),
                    nonce: noncesResult.result.toString(),
                    deadline: BigInt(Math.floor(Date.now() / 1000) + 30 * 60).toString(),
                };
                return {
                    primaryType: 'Permit',
                    domain,
                    types: abi_js_1.eip2612Types,
                    message,
                };
            }
            catch {
            }
        }
        const [nameResult, domainSeparatorResult, noncesResult, versionResult] = (await Promise.allSettled(contractCalls.map((call) => (0, getActionWithFallback_js_1.getActionWithFallback)(client, actions_1.readContract, 'readContract', call))));
        if (nameResult.status !== 'fulfilled' ||
            domainSeparatorResult.status !== 'fulfilled' ||
            noncesResult.status !== 'fulfilled') {
            return undefined;
        }
        const name = nameResult.value;
        const version = versionResult.status === 'fulfilled' ? versionResult.value : '1';
        const { isValid, domain } = validateDomainSeparator({
            name,
            version,
            chainId,
            verifyingContract: tokenAddress,
            domainSeparator: domainSeparatorResult.value,
        });
        if (!isValid) {
            return undefined;
        }
        const message = {
            owner: client.account.address,
            spender: spenderAddress,
            value: amount.toString(),
            nonce: noncesResult.value.toString(),
            deadline: BigInt(Math.floor(Date.now() / 1000) + 30 * 60).toString(),
        };
        return {
            primaryType: 'Permit',
            domain,
            types: abi_js_1.eip2612Types,
            message,
        };
    }
    catch {
        return undefined;
    }
};
exports.getNativePermit = getNativePermit;
//# sourceMappingURL=getNativePermit.js.map